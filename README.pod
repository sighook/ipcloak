=head1 NAME

ipcloak - render IPv4 addresses in alternate numeric forms

=head1 SYNOPSIS

B<ipcloak> <ip> [prefix] [postfix]

=head1 DESCRIPTION

B<ipcloak> takes an IPv4 address in canonical dotted-decimal form and
renders it into multiple alternate numeric representations.

These representations exploit ambiguities and legacy behavior in IPv4
parsing across operating systems, standard libraries, and network-aware
applications. While modern specifications define a strict syntax, many
real-world parsers continue to accept non-canonical forms.

B<ipcloak> is intended for security researchers performing:

=over 2

=item *

Input validation and normalization testing

=item *

Filter and WAF evasion research

=item *

Parser behavior analysis

=item *

Educational demonstrations of protocol ambiguity

=back

The tool emits textual representations only and does not perform any
network activity.

=head1 OPTIONS

=over 4

=item B<prefix>

Optional string printed before each generated representation.

=item B<postfix>

Optional string printed after each generated representation.

=back

=head1 GENERATED FORMATS

The following encoding classes are currently implemented.

=head2 Whole-address integer encodings

The IPv4 address rendered as a single 32-bit value:

=over 2

=item *

Decimal integer

  Example: 2130706433

=item *

Hexadecimal integer

  Example: 0x7F000001

=item *

Octal integer

  Example: 017700000001

=back

=head2 Per-octet encodings

Each octet rendered independently:

=over 2

=item *

Hexadecimal octets

  Example: 0x7F.0x00.0x00.0x01

=item *

Octal octets

  Example: 0177.0000.0000.0001

=item *

Fixed-width padded variants

  Example:
  0x000000007F.0x0000000000.0x0000000000.0x0000000001

=back

=head2 Mixed-base encodings

Combinations of hexadecimal, octal, and decimal components within a
single address.

  Examples:
  0x7F.0x00.1
  0177.0.0.1

These rely on parsers performing base detection per component.

=head2 Collapsed encodings

Adjacent octets collapsed into larger integer values:

=over 2

=item *

u16 - last two octets combined

  Example: 0x7F.0x00.256

=item *

u24 - last three octets combined

  Example: 0x7F.65536

=back

These reflect legacy parsing rules where fewer than four components
are provided.

=head1 FUTURE CLOAKS

The following cloaks are not currently implemented.
They are documented to provide researchers with awareness of
additional IPv4 parsing quirks and bypass vectors.

=over 2

=item * IPv6-mapped IPv4

IPv4 represented inside IPv6 notation:

  Example: ::ffff:127.0.0.1

Many stacks normalize IPv6-mapped addresses back to IPv4, bypassing
filters that only check dotted-quad notation.

=item * Mixed-case hex

Accept both lowercase and uppercase hex prefixes.

  Example: 0X7F000001

Case-insensitive parsers accept both, but regex filters often only
match lowercase "0x".

=item * Split dword forms

Break the 32-bit integer into two or more hex parts.

  Example: 0x7F.0x00000001

Some parsers treat split integers as valid, confusing filters
expecting a single token.

=item * Whitespace padding

Addresses with trailing or leading spaces.

  Example: "127.0.0.1 "

Lenient parsers trim whitespace, but filters may fail to normalize,
allowing bypass.

=item * Comment injection

Addresses with inline comments.

  Example: 127.0.0.1/*foo*/

Regex-based or lexical filters may ignore comments while parsers still
resolve the address.

=item * XOR-encoded cloaks

Obfuscate the dword with a key, then print the encoded integer.

  Example (XOR key 0xFF): 2147483646

Used in shellcode obfuscation to reduce entropy and evade
signature-based detection.

=item * Array cloaks

Represent the IP as a sequence of smaller IPs or integers.

  Example: [127.0.0.1, 0.0.0.0]

Payload formed as multiple IPs can slip past filters expecting a
single canonical address.

=item * IPv6 short forms

Compressed IPv6 notation that still resolves to IPv4.

  Example: ::7f00:1

IPv6 compression rules allow multiple equivalent encodings, confusing
simplistic validators.

=item * Overlong padded hex

Addresses padded with excessive leading zeros.

  Example: 0x0000000000000000007F000001

Parsers accept padded hex, but filters may not normalize, enabling
bypass.

=back

=head1 EXTENDING

To add new cloaks, define a subroutine that returns a string
representation of the IP, then register it in B<@formats>.

=head1 COLLAPSED FORMS

Some cloaks collapse octets into larger integers:

=over 2

=item * u16 = (octet3 << 8) | octet4

=item * u24 = (octet2 << 16) | (octet3 << 8) | octet4

=back

These match the original C program's "collapsed hybrid" outputs.

=head1 EXAMPLES

Render all cloaked forms of an address:

  ipcloak 127.0.0.1

Add markers around each output:

  ipcloak 192.168.100.1 "http://" "/endpoint"

=head1 SEE ALSO

L<inet_aton(3)>, L<inet_pton(3)>, RFC 791.

=head1 LIMITATIONS

=over 2

=item *

Only IPv4 addresses are supported.

=item *

Acceptance of generated forms depends entirely on the target parser.

=item *

Modern, strict implementations may reject most non-canonical encodings.

=back

=head1 HISTORY

Derived from IPObfuscator by Osanda Malith Jayathissa.

Original repository:
L<https://github.com/OsandaMalith/IPObfuscator>

=head1 AUTHOR

Original C implementation by Osanda Malith and 1lastBr3ath.

Perl refactor and documentation by Alexandr Savca.

=head1 LICENSE

This work is based on IPObfuscator by Osanda Malith Jayathissa and is
licensed under the Creative Commons Attribution-NonCommercial-ShareAlike
4.0 International License (CC BY-NC-SA 4.0).

You may share and adapt this work under the following conditions:

=over 2

=item * Attribution to the original author(s)

=item * Non-commercial use only

=item * ShareAlike: derivative works must use the same license

=back

See: L<http://creativecommons.org/licenses/by-nc-sa/4.0/>

=cut
